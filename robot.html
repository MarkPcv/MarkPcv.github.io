<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <link rel="stylesheet" type="text/css" href="style.css">
	<link rel="shortcut icon" href="robotic.png" />
    <title>H.A.R.M.</title>
  </head>
  <body>
    <div class ="header">
      <p id="title">MECHENG 706</p>
      <p id="degree">BE Mechatronics Engineering</p>
    </div>
    <div class="topnav">
      <p style="font-family: 'times new roman';font-size: 20px; font-style: italic; float: left; padding: 5px 20px 5px 50px" > "Once you stop learning, you start dying"</p>
      <ul>
      <li><a href="index.html" title="Home Webpage"> Home </a></li>
	  <li><a href="summary.html" title="Design Summary"> Summary </a></li>
      <li><a href="robot.html" title="Robot Features and Demos"> Robot </a></li>
    </ul>
    </div>

    <div class = "robot">
	<br>
      <h1 class="summary_header"> Major features of robot </h1>
	  <br>
	  <br>
	   <p class = "summary_content"> Robot functionality can be divided into several subsystems - each responsible for a specific behaviour and task functionality.
      </p>
	  <br>
	  <br>
		<h2 class = "summary_subheader"> Initialisation </h2>
		<br>
		<p class = "summary_content"> For H.A.R.M to efficiently navigate the arena, he needs a starting position and this process helps him get there. Initialisation involves driving straight until a wall is encountered,
									turning 90° and continuing on until a corner is reached.A zigzagging pattern along the long side of the arena is desired and so  H.A.R.M. rotates and times how long it takes to get to the second corner.
										From here, he can determine whether to start zigzagging or should drive to the third corner before starting his usual zigzagging pattern.

      </p>
	  <img class = "robot_img" src = "./robot/init.png" style="width: 600px ; height: auto; margin: 50px auto 20px ;" >
		<br>
		<br>
		<h2 class = "summary_subheader"> Motion Control </h2>
		<br>
		<p class = "summary_content"> To ensure H.A.R.M drives straight, each wheel was initially roughly tuned for straight control. During run-time, a proportional controller then fine tunes these control
										inputs by taking gyroscopic measurements from the MPU to determine when it is drifting from the desired path.
      </p>
		<br>
		<br>
		<h2 class = "summary_subheader"> Arena Traversal </h2>
		<br>
		<p class = "summary_content">To traverse the arena H.A.R.M. is programmed to find a wall, turn 90°, drive straight to avoid double area coverage and turn another 90° before continuing straight.
										To achieve zigzagging, the direction of rotation is changed after each wall encounter.
      </p>
	  <img class = "robot_img" src = "./robot/long.png" style="width: 400px ; height: auto; margin: 50px auto 20px ;" >
		<br>
		<p class = "summary_content"> Whenever a wall is found, H.A.R.M uses his front outer sensors to align perpendicularly with the wall and as turning can also be rather tricky and introduce overshoot,
										the side sensors are used in a similar way to align parallel to the wall. This sets up H.A.R.M. nicely relative to the arena and ensures any directional error from the last path run does not affect the next.
      </p>


	  <img class = "robot_img" src = "./robot/front.png" style="width: 300px ; height: auto; margin: 50px auto 20px ; display:inline-block; margin-left:200px;" >
	  <img class = "robot_img" src = "./robot/side.png" style="width: 300px ; height: auto; margin: 50px auto 20px ; display:inline-block; margin-left: 100px" >
		<br>
		<br>
		<h2 class = "summary_subheader"> Obstacle Avoidance </h2>
		<br>
		<p class = "summary_content"> When an obstacle is detected H.A.R.M strafes to the right and times how long it takes to horizontally clear the obstacle (with his front left sensor no indicating an object is no longer in front).
										He then proceeds to pass the obstacle on the right and waits for his back IR sensor to detect no obstacle. Finally H.A.R.M strafes back left for the same amount of time it took to strafe right.
      </p>
		<img class = "robot_img" src = "./robot/Ob1.png" style="width: 200px ; height: auto; margin: 50px auto 20px ; display:inline-block; margin-left: 150px" >
		<img class = "robot_img" src = "./robot/Ob2.png" style="width: 200px ; height: auto; margin: 50px auto 20px ; display:inline-block; margin-left: 100px" >
		<img class = "robot_img" src = "./robot/Ob3.png" style="width: 200px ; height: auto; margin: 50px auto 20px ; display:inline-block; margin-left: 100px" >
		<br>
		<br>
		<br>
		<h2 class = "summary_subheader"> Fire-Fighting </h2>
		<br>
		<p class = "summary_content"> When an obstacle is detected, H.A.R.M stops and uses his fire-fighting unit to scan the field in front of him. If a fire is detected, his fan is actuated so that it tracks and directly faces the flame.
										The fan is then activated and when the phototransistors indicate the fire has been successfully extinguished, obstacle avoidance commences.
      </p>
		<br>
		<br>
		<h2 class = "summary_subheader"> SLAM </h2>
		<br>
		<p class = "summary_content"> When H.A.R.M first initialises himself into a corner, he sets this as his starting reference position. Everytime a wall or obstacle is encountered, localisation data and information about his whereabouts is stored in memory as an array. His position is output as a set of x and y-coordinates and is determined through dead reckoning which uses knowledge about his last position, speed and the elapsed time since the last update. Using his proximity sensors and phototransistors,
										H.A.R.M also determines if it is a wall or an obstacle he has approached and whether a fire is present. At the end of his run, H.A.R.M then hands this information over so it can be turned into a map and he can have a memento of his adventures.
      </p>

		<br>


		<br>

    </div>










    <!-- SLideshow Container -->
    <div class="slideshow">
		<br>
		<p style="font-family:'Arial';font-size: 80%;font-style: italic; font-weight: bold; text-align: center;  padding: 0px 0px 0px 0px;"> The demonstration of each subsystem functionality is shown in the following videos </p>
		<br>
      <!-- Full-width images with number and caption text -->
      <div class="mySlides fade" style="margin-top: 0px;">

          <video width="100%" height="auto" controls src="./clips/init.mp4">
          </video>
            <div class="text1" style="font-family:'Arial';font-size: 100%;font-style: italic;"> Initialisation demonstration </div>
      </div>
      <div class="mySlides fade" style="margin-top: 0px;">

          <video width="100%" height="auto" controls src="./clips/arena.mp4">
          </video>
            <div class="text1" style="font-family:'Arial';font-size: 100%;font-style: italic;"> Arena Traversal demonstration </div>
      </div>

      <div class="mySlides fade" style="margin-top: 0px;">

          <video width="100%" height="auto" controls src="./clips/avoid.mp4">
          </video>
            <div class="text1" style="font-family:'Arial';font-size: 100%;font-style: italic;"> Obstacle Avoidance demonstration </div>
      </div>


      <div class="mySlides fade">
        <video width="width" height="auto" controls src="./clips/fire.mp4">
        </video>
        <div class="text1" style="font-family:'Arial';font-size: 100%;font-style: italic">Fire Extinguishing Subsystem demonstration</div>

      </div>


      <!-- Next and previous buttons -->
      <a class="prev" onclick="plusSlides(-1)">&#10094;</a>
      <a class="next" onclick="plusSlides(1)">&#10095;</a>
    </div>
    <br>
    <!-- The dots/circles -->
    <div style="text-align:center">
      <span class="dot" onclick="currentSlide(1)"></span>
      <span class="dot" onclick="currentSlide(2)"></span>
      <span class="dot" onclick="currentSlide(3)"></span>
        <span class="dot" onclick="currentSlide(4)"></span>
  </div>



<script>
    var slideIndex = 1;
    showSlides(slideIndex);

    function plusSlides(n) {
      showSlides(slideIndex += n);
    }

    function currentSlide(n) {
      showSlides(slideIndex = n);
    }

    function showSlides(n) {
      var i;
      var slides = document.getElementsByClassName("mySlides");
      var dots = document.getElementsByClassName("dot");
      if (n > slides.length) {slideIndex = 1}
      if (n < 1) {slideIndex = slides.length}
      for (i = 0; i < slides.length; i++) {
          slides[i].style.display = "none";
      }
      for (i = 0; i < dots.length; i++) {
          dots[i].className = dots[i].className.replace(" active", "");
      }
      slides[slideIndex-1].style.display = "block";
      dots[slideIndex-1].className += " active";
    }
</script>

  </body>
</html>
